---
title: "MRS-Testing-git"
author: "shahin"
date: "11/03/2020"
output: html_document
---
## Capstone Project-Movie Recommendation Systems
## Establish connection between R Project with github Repo

```{r}
if(!require(tidyverse)) 
  install.packages("tidyverse", repos = "http://cran.us.r-project.org") #[it loads ggplot2, tibble, tidyr, readr, purrr, and dplyr packages]
if(!require(caret)) 
  install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) 
  install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(knitr)) 
  install.packages("knitr", repos = "http://cran.us.r-project.org")
if(!require(recommenderlab)) 
  install.packages("recommenderlab", repos = "http://cran.us.r-project.org")
if(!require(reshape2)) 
  install.packages("reshape2", repos = "http://cran.us.r-project.org")
#if(!require(dplyr)) 
#  install.packages("dplyr", repos = "http://cran.us.r-project.org")
#if(!require(ggplot2)) 
#  install.packages("ggplot2", repos = "http://cran.us.r-project.org")
#library(dplyr)
#library(ggplot2)
#library(knitr)
#install.packages("recommenderlab")
#library(recommenderlab)
#install.packages("reshape2") # may already be installed
#library(reshape2)
#library (readr)
```
## Project overview: 
The goal of this project is to give a better understanding of User Based Collaborative Filter (UBCF) and Item Based Collaborative Filter (IBCF) models for hybrid recommender systems by answering the following question:

With what level of performance can collaborative filtering using UBCF and IBCF models produce movie recommendations based on movies and userâ€™s ratings data?

## Datasets
The dataset I choose for this project is from GroupLens research lab in the University of Minnesota and available in the MovieLens website which contains four files such as movies.csv, ratings.csv, links.csv and tags.csv. 
To build a recommendar system I used only movies.csv and ratings.csv data files.

```{r}
movies_url="https://raw.githubusercontent.com/sahmed07/MRS-Testing/main/movies.csv"
movies<-read_csv(url(movies_url))
movies <- as_tibble(movies)
movies
```
#Exploring the movies table and variables:
```{r}
str(movies)
```
```{r}
glimpse(movies)
summary(movies)
```
```{r}
ratings_url="https://raw.githubusercontent.com/sahmed07/MRS-Testing/main/ratings.csv"
ratings<-read_csv(url(ratings_url))
#remove the timestamp as it may not be required for this project
ratings <- subset(ratings, select = -c(timestamp) )
ratings <- as_tibble(ratings)
ratings
```
#Exploring the ratings table and variables:
```{r}
str(ratings)
```
```{r}
glimpse(ratings)
summary(ratings)
```

## Data Exploration and pre-processing
# most popular movie genres
```{r}
genres_df <- movies %>%
  separate_rows(genres, sep = "\\|") %>%
  group_by(genres) %>%
  summarise(number = n()) %>%
  arrange(desc(number))

genres_df
```
# Based on Ratings which is the best/top Movie?
```{r}
# average rating for a movie
avg_rating <- ratings %>%
  inner_join(movies, by = "movieId") %>%
  na.omit() %>%
  select(title, rating) %>%
  group_by(title, rating) %>%
  summarise(count = n(), mean = mean(rating), min = min(rating), max = max(rating)) %>%
  ungroup() %>%
  arrange(desc(mean))

avg_rating

weighted_rating <- function(R, v, m, C) {
  return (v/(v+m))*R + (m/(v+m))*C
}

avg_rating <- avg_rating %>%
  mutate(wr = weighted_rating(mean, count, 500, mean(mean))) %>%
  arrange(desc(wr)) %>%
  select(title, rating, count, mean, wr)

avg_rating
```
# Split genre and create a search matrix
```{r}
movie_genre <- as.data.frame(movies$genres, stringsAsFactors = FALSE)
movie_genre_2 <- as.data.frame(tstrsplit(movie_genre[,1], "[|]", type.convert = TRUE),stringsAsFactors = FALSE)

colnames(movie_genre_2) <- c(1:10)

genre_list <- c("Action", "Adventure", "Animation", "Children", 
                "Comedy", "Crime","Documentary", "Drama", "Fantasy",
                "Film-Noir", "Horror", "Musical", "Mystery","Romance",
                "Sci-Fi", "Thriller", "War", "Western")

genre_matx <- matrix(0,9743,18)
genre_matx[1,] <- genre_list
colnames(genre_matx) <- genre_list

for (index in 1:nrow(movie_genre_2)){
  for(col in 1:ncol(movie_genre_2)){
    gen_col = which(genre_matx[1,] == movie_genre_2[index,col])
    genre_matx[index+1,gen_col] <- 1
  }
}

genre_matx_2 <- as.data.frame(genre_matx[-1,], stringsAsFactors=FALSE)

for (col in 1:ncol(genre_matx_2)) {
  genre_matx_2[,col] <- as.integer(genre_matx_2[,col])
}

head(genre_matx_2)
```
# define a search matrix
```{r}
search_matrix <- cbind(movies[,1:2], genre_mat2)
head(search_matrix)
```
# Number of ratings and count of each ratings
```{r}
vector_ratings <- as.vector(ratings$rating)
sort(unique(vector_ratings))
table_ratings <- table(vector_ratings)
table_ratings
```
# Visulization of ratinga count
```{r}
vector_ratings <- factor(vector_ratings)
qplot(vector_ratings) + 
  ggtitle("Distribution of the ratings")
```
## Data Preparation
#converting rating matrix into a sparse matrix of class type *realRatingMatrix*

```{r}
#Create ratings matrix. Rows = userId, Columns = movieId
ratingmat <- dcast(ratings, userId~movieId, value.var = "rating", na.rm=FALSE)
ratingmat <- as.matrix(ratingmat[,-1])

#Convert rating matrix into a recommenderlab sparse matrix
ratingmat <- as(ratingmat, "realRatingMatrix")
ratingmat
```
#In order to predict the most relevant data, rating matrix is defined with the minimum number of users per rated movie as 50 and the minimum views number per movie as 50:
```{r}
ratings_movies <- ratingmat[rowCounts(ratingmat) > 50,
                             colCounts(ratingmat) > 50]
ratings_movies
ratingmat
```
# Create a Train and Test set
```{r}
which_train <- sample(x = c(TRUE, FALSE), 
                      size = nrow(ratings_movies),
                      replace = TRUE, 
                      prob = c(0.8, 0.2))

recc_data_train <- ratings_movies[which_train, ]
recc_data_test <- ratings_movies[!which_train, ]
```

# Normalize the data
```{r}
ratings_movies_norm <- recommenderlab::normalize(ratings_movies)
sum(rowMeans(ratings_movies_norm) > 0.00001)
```
# visualize the normalized matrix for the top movies
```{r viz_normal_data, warning=FALSE, error=FALSE, echo=FALSE}
image(ratings_movies_norm[rowCounts(ratings_movies_norm) > min_movies,
                          colCounts(ratings_movies_norm) > min_users], 
main = "Heatmap of the top users and movies")
```
```{r}
?Recommender
recommender_models <- recommenderRegistry$get_entries(dataType = "realRatingMatrix")
names(recommender_models)
lapply(recommender_models, "[[", "description")
```
# I will use IBCF and UBCF models. Check the parameters of these two models.

```{r model_param, warning=FALSE, error=FALSE}
recommender_models$IBCF_realRatingMatrix$parameters
recommender_models$UBCF_realRatingMatrix$parameters
```
#Create Recommender Model with "UBCF" on train set
```{r}
recommender_model <- Recommender(recc_data_train, method = "UBCF", param=list(method="Cosine",nn=30))
recom <- predict(recommender_model, recc_data_train[1], n=5)
recom_list <- as(recom, "list")
 
recom_result <- matrix(0,5)
for (i in c(1:5)){
 recom_result[i] <- search_matrix[as.integer(recom_list[[1]][i]),2]
}

recom_result
```
```{r}
evaluation_scheme <- evaluationScheme(recc_data_train, method="cross-validation", k=5, given=3, goodRating=5)
evaluation_results <- evaluate(evaluation_scheme, method="UBCF", n=c(1,3,5,10,15,20))
eval_results <- getConfusionMatrix(evaluation_results)[[1]]
eval_results
```
#Create Recommender Model with "UBCF" on train set
```{r}
recommender_models <- recommenderRegistry$get_entries(dataType ="realRatingMatrix")
recommender_models$UBCF_realRatingMatrix$parameters
rec_mod <- Recommender(recc_data_train, method = "UBCF", param=list(method="Cosine",nn=10))
rec_mod
model_details <- getModel(recc_model)
model_details$data

top_5_pred <- predict(rec_mod, recc_data_train[1], n=5)
top_5_pred
top_5_List <- as(top_5_pred, "list")
top_5_List
top_5_df <- data.frame(top_5_List)
colnames(top_5_df) <- "movieId"
top_5_df$movieId <- as.numeric(levels(top_5_df$movieId))
names <- left_join(top_5_df, search_matrix, by = "movieId")
names
```
## Applying the recommender model on the test set

Determine the top ten recommendations for each new user in the test set. 

```{r}
n_recommended <- 10
recc_predicted <- predict(object = rec_mod,
                          newdata = recc_data_test, 
                          n = n_recommended) 
recc_predicted
```
## Explore results

Let's take a look at the first four users:

```{r}
recc_matrix <- sapply(recc_predicted@items, 
                      function(x){ as.integer(colnames(ratings_movies)[x]) })
#dim(recc_matrix)
recc_matrix[, 1:4]
```

```{r}
links_url="https://raw.githubusercontent.com/sahmed07/MRS-Testing/main/links.csv"
links<-read_csv(url(links_url))
glimpse(links)
summary(links)
head(links)
```
```{r}
tags_url="https://raw.githubusercontent.com/sahmed07/MRS-Testing/main/tags.csv"
tags<-read_csv(url(tags_url))
#remove the timestamp as it may not be required for this project
tags <- subset(tags, select = -c(timestamp) )
glimpse(tags)
summary(tags)
head(tags)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
